/*!
 * better-scroll / zoom
 * (c) 2016-2020 ustbhuangyi
 * Released under the MIT License.
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.Zoom = factory());
}(this, function () { 'use strict';

  var sourcePrefix = 'plugins.zoom';
  var propertiesMap = [
      {
          key: 'zoomTo',
          name: 'zoomTo'
      }
  ];
  var propertiesConfig = propertiesMap.map(function (item) {
      return {
          key: item.key,
          sourceKey: sourcePrefix + "." + item.name
      };
  });

  // ssr support
  var inBrowser = typeof window !== 'undefined';
  var ua = inBrowser && navigator.userAgent.toLowerCase();
  var isWeChatDevTools = ua && /wechatdevtools/.test(ua);
  var isAndroid = ua && ua.indexOf('android') > 0;

  function isUndef(v) {
      return v === undefined || v === null;
  }
  function getDistance(x, y) {
      return Math.sqrt(x * x + y * y);
  }
  function fixInboundValue(x, min, max) {
      if (x < min) {
          return min;
      }
      if (x > max) {
          return max;
      }
      return x;
  }

  var elementStyle = (inBrowser &&
      document.createElement('div').style);
  var vendor = (function () {
      if (!inBrowser) {
          return false;
      }
      var transformNames = {
          webkit: 'webkitTransform',
          Moz: 'MozTransform',
          O: 'OTransform',
          ms: 'msTransform',
          standard: 'transform'
      };
      for (var key in transformNames) {
          if (elementStyle[transformNames[key]] !== undefined) {
              return key;
          }
      }
      return false;
  })();
  function prefixStyle(style) {
      if (vendor === false) {
          return style;
      }
      if (vendor === 'standard') {
          if (style === 'transitionEnd') {
              return 'transitionend';
          }
          return style;
      }
      return vendor + style.charAt(0).toUpperCase() + style.substr(1);
  }
  function offsetToBody(el) {
      var rect = el.getBoundingClientRect();
      return {
          left: -(rect.left + window.pageXOffset),
          top: -(rect.top + window.pageYOffset)
      };
  }
  var cssVendor = vendor && vendor !== 'standard' ? '-' + vendor.toLowerCase() + '-' : '';
  var transform = prefixStyle('transform');
  var transition = prefixStyle('transition');
  var hasPerspective = inBrowser && prefixStyle('perspective') in elementStyle;
  var style = {
      transform: transform,
      transition: transition,
      transitionTimingFunction: prefixStyle('transitionTimingFunction'),
      transitionDuration: prefixStyle('transitionDuration'),
      transitionDelay: prefixStyle('transitionDelay'),
      transformOrigin: prefixStyle('transformOrigin'),
      transitionEnd: prefixStyle('transitionEnd')
  };
  function getRect(el) {
      if (el instanceof window.SVGElement) {
          var rect = el.getBoundingClientRect();
          return {
              top: rect.top,
              left: rect.left,
              width: rect.width,
              height: rect.height
          };
      }
      else {
          return {
              top: el.offsetTop,
              left: el.offsetLeft,
              width: el.offsetWidth,
              height: el.offsetHeight
          };
      }
  }

  var DEFAULT_INTERVAL = 100 / 60;
  var windowCompat = inBrowser && window;
  function noop() { }
  var requestAnimationFrame = (function () {
      if (!inBrowser) {
          /* istanbul ignore if */
          return noop;
      }
      return (windowCompat.requestAnimationFrame ||
          windowCompat.webkitRequestAnimationFrame ||
          windowCompat.mozRequestAnimationFrame ||
          windowCompat.oRequestAnimationFrame ||
          // if all else fails, use setTimeout
          function (callback) {
              return window.setTimeout(callback, (callback.interval || DEFAULT_INTERVAL) / 2); // make interval as precise as possible.
          });
  })();
  var cancelAnimationFrame = (function () {
      if (!inBrowser) {
          /* istanbul ignore if */
          return noop;
      }
      return (windowCompat.cancelAnimationFrame ||
          windowCompat.webkitCancelAnimationFrame ||
          windowCompat.mozCancelAnimationFrame ||
          windowCompat.oCancelAnimationFrame ||
          function (id) {
              window.clearTimeout(id);
          });
  })();

  var Zoom = /** @class */ (function () {
      function Zoom(scroll) {
          this.scroll = scroll;
          this.scale = 1;
          this.scroll.proxy(propertiesConfig);
          this.scroll.registerType(['zoomStart', 'zoomEnd']);
          this.zoomOpt = this.scroll.options.zoom;
          this.lastTransformScale = this.scale;
          this.hooksFn = [];
          this.init();
      }
      Zoom.prototype.init = function () {
          var _this = this;
          var scrollerIns = this.scroll.scroller;
          this.wrapper = this.scroll.scroller.wrapper;
          this.scaleElement = this.scroll.scroller.content;
          this.scaleElement.style[style.transformOrigin] = '0 0';
          this.scaleElementInitSize = getRect(this.scaleElement);
          var scrollBehaviorX = scrollerIns.scrollBehaviorX;
          var scrollBehaviorY = scrollerIns.scrollBehaviorY;
          this.initScrollBoundary = {
              x: [scrollBehaviorX.minScrollPos, scrollBehaviorX.maxScrollPos],
              y: [scrollBehaviorY.minScrollPos, scrollBehaviorY.maxScrollPos]
          };
          this.registorHooks(scrollerIns.actions.hooks, 'start', function (e) {
              if (e.touches && e.touches.length > 1) {
                  _this.zoomStart(e);
              }
          });
          this.registorHooks(scrollerIns.actions.hooks, 'beforeMove', function (e) {
              if (!e.touches || e.touches.length < 2) {
                  return false;
              }
              _this.zoom(e);
              return true;
          });
          this.registorHooks(scrollerIns.actions.hooks, 'beforeEnd', function (e) {
              if (!_this.zooming) {
                  return false;
              }
              _this.zoomEnd();
              return true;
          });
          this.registorHooks(scrollerIns.translater.hooks, 'beforeTranslate', function (transformStyle, point) {
              var scale = point.scale ? point.scale : _this.lastTransformScale;
              _this.lastTransformScale = scale;
              transformStyle.push("scale(" + scale + ")");
          });
          this.registorHooks(scrollerIns.hooks, 'ignoreDisMoveForSamePos', function () {
              return true;
          });
          this.registorHooks(this.scroll.hooks, 'destroy', this.destroy);
      };
      Zoom.prototype.zoomTo = function (scale, x, y) {
          var _a = offsetToBody(this.wrapper), left = _a.left, top = _a.top;
          var originX = x + left - this.scroll.x;
          var originY = y + top - this.scroll.y;
          this.zooming = true;
          this._zoomTo(scale, { x: originX, y: originY }, this.scale);
          this.zooming = false;
      };
      Zoom.prototype.zoomStart = function (e) {
          this.zooming = true;
          var firstFinger = e.touches[0];
          var secondFinger = e.touches[1];
          this.startDistance = this.getFingerDistance(e);
          this.startScale = this.scale;
          var _a = offsetToBody(this.wrapper), left = _a.left, top = _a.top;
          this.origin = {
              x: Math.abs(firstFinger.pageX + secondFinger.pageX) / 2 +
                  left -
                  this.scroll.x,
              y: Math.abs(firstFinger.pageY + secondFinger.pageY) / 2 +
                  top -
                  this.scroll.y
          };
          this.scroll.trigger(this.scroll.eventTypes.zoomStart);
      };
      Zoom.prototype.zoom = function (e) {
          var scrollerIns = this.scroll.scroller;
          var currentDistance = this.getFingerDistance(e);
          var currentScale = (currentDistance / this.startDistance) * this.startScale;
          this.scale = this.scaleCure(currentScale);
          var lastScale = this.scale / this.startScale;
          var scrollBehaviorX = scrollerIns.scrollBehaviorX;
          var scrollBehaviorY = scrollerIns.scrollBehaviorY;
          var x = this.getNewPos(this.origin.x, lastScale, scrollBehaviorX);
          var y = this.getNewPos(this.origin.y, lastScale, scrollBehaviorY);
          this.resetBoundaries(this.scale, scrollBehaviorX, 'x', x);
          this.resetBoundaries(this.scale, scrollBehaviorY, 'y', y);
          scrollerIns.scrollTo(x, y, 0, undefined, {
              start: {
                  scale: this.lastTransformScale
              },
              end: {
                  scale: this.scale
              }
          });
      };
      Zoom.prototype.getFingerDistance = function (e) {
          var firstFinger = e.touches[0];
          var secondFinger = e.touches[1];
          var deltaX = Math.abs(firstFinger.pageX - secondFinger.pageX);
          var deltaY = Math.abs(firstFinger.pageY - secondFinger.pageY);
          return getDistance(deltaX, deltaY);
      };
      Zoom.prototype.zoomEnd = function () {
          this._zoomTo(this.scale, this.origin, this.startScale || this.scale);
          this.zooming = false;
          this.scroll.trigger(this.scroll.eventTypes.zoomEnd);
      };
      Zoom.prototype.destroy = function () {
          this.hooksFn.forEach(function (item) {
              var hooks = item[0];
              var hooksName = item[1];
              var handlerFn = item[2];
              hooks.off(hooksName, handlerFn);
          });
          this.hooksFn.length = 0;
      };
      Zoom.prototype._zoomTo = function (scale, origin, startScale) {
          this.scale = this.fixInScaleLimit(scale);
          var lastScale = this.scale / startScale;
          var scrollerIns = this.scroll.scroller;
          var scrollBehaviorX = scrollerIns.scrollBehaviorX;
          var scrollBehaviorY = scrollerIns.scrollBehaviorY;
          this.resetBoundaries(this.scale, scrollBehaviorX, 'x');
          this.resetBoundaries(this.scale, scrollBehaviorY, 'y');
          // resetPosition
          var newX = this.getNewPos(origin.x, lastScale, scrollBehaviorX, true);
          var newY = this.getNewPos(origin.y, lastScale, scrollBehaviorY, true);
          if (scrollBehaviorX.currentPos !== Math.round(newX) ||
              scrollBehaviorY.currentPos !== Math.round(newY) ||
              this.scale !== this.lastTransformScale) {
              scrollerIns.scrollTo(newX, newY, this.scroll.options.bounceTime, undefined, {
                  start: {
                      scale: this.lastTransformScale
                  },
                  end: {
                      scale: this.scale
                  }
              });
          }
      };
      Zoom.prototype.resetBoundaries = function (scale, scrollBehavior, direction, extendValue) {
          var min = this.initScrollBoundary[direction][0];
          var max = this.initScrollBoundary[direction][1];
          var hasScroll = false;
          if (scale > 1) {
              var sideName = direction === 'x' ? 'width' : 'height';
              max =
                  -this.scaleElementInitSize[sideName] * (scale - 1) -
                      this.initScrollBoundary[direction][1];
              hasScroll = true;
          }
          if (!isUndef(extendValue)) {
              max = Math.min(extendValue, max);
              min = Math.max(extendValue, min); // max & min & curValue is negative value
              hasScroll = !!(min || max);
          }
          scrollBehavior.minScrollPos = Math.floor(min);
          scrollBehavior.maxScrollPos = Math.floor(max);
          scrollBehavior.hasScroll = hasScroll;
      };
      Zoom.prototype.getNewPos = function (origin, lastScale, scrollBehavior, fixInBound) {
          var newPos = origin - origin * lastScale + scrollBehavior.startPos;
          if (fixInBound) {
              newPos = fixInboundValue(newPos, scrollBehavior.maxScrollPos, 0);
          }
          return Math.floor(newPos);
      };
      Zoom.prototype.scaleCure = function (scale) {
          var _a = this.zoomOpt, _b = _a.min, min = _b === void 0 ? 1 : _b, _c = _a.max, max = _c === void 0 ? 4 : _c;
          if (scale < min) {
              scale = 0.5 * min * Math.pow(2.0, scale / min);
          }
          else if (scale > max) {
              scale = 2.0 * max * Math.pow(0.5, max / scale);
          }
          return scale;
      };
      Zoom.prototype.fixInScaleLimit = function (scale) {
          var _a = this.zoomOpt, _b = _a.min, min = _b === void 0 ? 1 : _b, _c = _a.max, max = _c === void 0 ? 4 : _c;
          if (scale > max) {
              scale = max;
          }
          else if (scale < min) {
              scale = min;
          }
          return scale;
      };
      Zoom.prototype.registorHooks = function (hooks, name, handler) {
          hooks.on(name, handler, this);
          this.hooksFn.push([hooks, name, handler]);
      };
      Zoom.pluginName = 'zoom';
      return Zoom;
  }());

  return Zoom;

}));
