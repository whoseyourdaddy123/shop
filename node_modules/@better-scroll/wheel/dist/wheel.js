/*!
 * better-scroll / wheel
 * (c) 2016-2020 ustbhuangyi
 * Released under the MIT License.
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.Wheel = factory());
}(this, function () { 'use strict';

  // ssr support
  var inBrowser = typeof window !== 'undefined';
  var ua = inBrowser && navigator.userAgent.toLowerCase();
  var isWeChatDevTools = ua && /wechatdevtools/.test(ua);
  var isAndroid = ua && ua.indexOf('android') > 0;

  function isPlainObject(v) {
      return typeof v === 'object' && v !== null;
  }

  var elementStyle = (inBrowser &&
      document.createElement('div').style);
  var vendor = (function () {
      if (!inBrowser) {
          return false;
      }
      var transformNames = {
          webkit: 'webkitTransform',
          Moz: 'MozTransform',
          O: 'OTransform',
          ms: 'msTransform',
          standard: 'transform'
      };
      for (var key in transformNames) {
          if (elementStyle[transformNames[key]] !== undefined) {
              return key;
          }
      }
      return false;
  })();
  function prefixStyle(style) {
      if (vendor === false) {
          return style;
      }
      if (vendor === 'standard') {
          if (style === 'transitionEnd') {
              return 'transitionend';
          }
          return style;
      }
      return vendor + style.charAt(0).toUpperCase() + style.substr(1);
  }
  var cssVendor = vendor && vendor !== 'standard' ? '-' + vendor.toLowerCase() + '-' : '';
  var transform = prefixStyle('transform');
  var transition = prefixStyle('transition');
  var hasPerspective = inBrowser && prefixStyle('perspective') in elementStyle;
  var style = {
      transform: transform,
      transition: transition,
      transitionTimingFunction: prefixStyle('transitionTimingFunction'),
      transitionDuration: prefixStyle('transitionDuration'),
      transitionDelay: prefixStyle('transitionDelay'),
      transformOrigin: prefixStyle('transformOrigin'),
      transitionEnd: prefixStyle('transitionEnd')
  };
  function getRect(el) {
      if (el instanceof window.SVGElement) {
          var rect = el.getBoundingClientRect();
          return {
              top: rect.top,
              left: rect.left,
              width: rect.width,
              height: rect.height
          };
      }
      else {
          return {
              top: el.offsetTop,
              left: el.offsetLeft,
              width: el.offsetWidth,
              height: el.offsetHeight
          };
      }
  }
  function hasClass(el, className) {
      var reg = new RegExp('(^|\\s)' + className + '(\\s|$)');
      return reg.test(el.className);
  }

  var ease = {
      // easeOutQuint
      swipe: {
          style: 'cubic-bezier(0.23, 1, 0.32, 1)',
          fn: function (t) {
              return 1 + --t * t * t * t * t;
          }
      },
      // easeOutQuard
      swipeBounce: {
          style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
          fn: function (t) {
              return t * (2 - t);
          }
      },
      // easeOutQuart
      bounce: {
          style: 'cubic-bezier(0.165, 0.84, 0.44, 1)',
          fn: function (t) {
              return 1 - --t * t * t * t;
          }
      }
  };

  var DEFAULT_INTERVAL = 100 / 60;
  var windowCompat = inBrowser && window;
  function noop() { }
  var requestAnimationFrame = (function () {
      if (!inBrowser) {
          /* istanbul ignore if */
          return noop;
      }
      return (windowCompat.requestAnimationFrame ||
          windowCompat.webkitRequestAnimationFrame ||
          windowCompat.mozRequestAnimationFrame ||
          windowCompat.oRequestAnimationFrame ||
          // if all else fails, use setTimeout
          function (callback) {
              return window.setTimeout(callback, (callback.interval || DEFAULT_INTERVAL) / 2); // make interval as precise as possible.
          });
  })();
  var cancelAnimationFrame = (function () {
      if (!inBrowser) {
          /* istanbul ignore if */
          return noop;
      }
      return (windowCompat.cancelAnimationFrame ||
          windowCompat.webkitCancelAnimationFrame ||
          windowCompat.mozCancelAnimationFrame ||
          windowCompat.oCancelAnimationFrame ||
          function (id) {
              window.clearTimeout(id);
          });
  })();

  var sourcePrefix = 'plugins.wheel';
  var propertiesMap = [
      {
          key: 'wheelTo',
          name: 'wheelTo'
      },
      {
          key: 'getSelectedIndex',
          name: 'getSelectedIndex'
      }
  ];
  var propertiesConfig = propertiesMap.map(function (item) {
      return {
          key: item.key,
          sourceKey: sourcePrefix + "." + item.name
      };
  });

  var CONSTANTS = {
      rate: 4
  };
  var Wheel = /** @class */ (function () {
      function Wheel(scroll) {
          this.scroll = scroll;
          this.options = this.scroll.options.wheel;
          this.init();
      }
      Wheel.prototype.init = function () {
          if (this.options) {
              this.normalizeOptions();
              this.refresh();
              this.tapIntoHooks();
              this.wheelTo(this.selectedIndex);
              this.scroll.proxy(propertiesConfig);
          }
      };
      Wheel.prototype.tapIntoHooks = function () {
          var _this = this;
          var scroller = this.scroll.scroller;
          var actionsHandler = scroller.actionsHandler;
          var scrollBehaviorY = scroller.scrollBehaviorY;
          var animater = scroller.animater;
          // BScroll
          this.scroll.on(this.scroll.hooks.eventTypes.refresh, function () {
              _this.refresh();
          });
          // Scroller
          scroller.hooks.on(scroller.hooks.eventTypes.checkClick, function () {
              var index = Array.from(_this.items).indexOf(_this.target);
              if (index === -1)
                  return true;
              _this.wheelTo(index, _this.options.adjustTime, ease.swipe);
              return true;
          });
          scroller.hooks.on(scroller.hooks.eventTypes.scrollTo, function (endPoint) {
              endPoint.y = _this.findNearestValidWheel(endPoint.y).y;
          });
          scroller.hooks.on(scroller.hooks.eventTypes.scrollToElement, function (el, pos) {
              if (!hasClass(el, _this.options.wheelItemClass)) {
                  return true;
              }
              else {
                  pos.top = _this.findNearestValidWheel(pos.top).y;
              }
          });
          scroller.hooks.on(scroller.hooks.eventTypes.ignoreDisMoveForSamePos, function () {
              return true;
          });
          // ActionsHandler
          actionsHandler.hooks.on(actionsHandler.hooks.eventTypes.beforeStart, function (e) {
              _this.target = e.target;
          });
          // ScrollBehaviorY
          scrollBehaviorY.hooks.on(scrollBehaviorY.hooks.eventTypes.momentum, function (momentumInfo, distance) {
              momentumInfo.rate = CONSTANTS.rate;
              momentumInfo.destination = _this.findNearestValidWheel(momentumInfo.destination).y;
              var maxDistance = 1000;
              var minDuration = 800;
              if (distance < maxDistance) {
                  momentumInfo.duration = Math.max(minDuration, (distance / maxDistance) * _this.scroll.options.swipeTime);
              }
          });
          scrollBehaviorY.hooks.on(scrollBehaviorY.hooks.eventTypes.end, function (momentumInfo) {
              var validWheel = _this.findNearestValidWheel(scrollBehaviorY.currentPos);
              momentumInfo.destination = validWheel.y;
              momentumInfo.duration = _this.options.adjustTime;
              _this.selectedIndex = validWheel.index;
          });
          // Animater
          animater.hooks.on(animater.hooks.eventTypes.time, function (time) {
              _this.transitionDuration(time);
          });
          animater.hooks.on(animater.hooks.eventTypes.timeFunction, function (easing) {
              _this.timeFunction(easing);
          });
          animater.hooks.on(animater.hooks.eventTypes.beforeForceStop, function (_a) {
              var y = _a.y;
              _this.target = _this.items[_this.findNearestValidWheel(y).index];
              // don't dispatch scrollEnd when it is a click operation
              return true;
          });
          // Translater
          animater.translater.hooks.on(animater.translater.hooks.eventTypes.translate, function (endPoint) {
              _this.rotateX(endPoint.y);
              _this.selectedIndex = _this.findNearestValidWheel(endPoint.y).index;
          });
      };
      Wheel.prototype.refresh = function () {
          var scroller = this.scroll.scroller;
          var scrollBehaviorY = scroller.scrollBehaviorY;
          // adjust contentSize
          var contentRect = getRect(scroller.content);
          scrollBehaviorY.contentSize = contentRect.height;
          this.items = scroller.content.children;
          this.checkWheelAllDisabled();
          this.itemHeight = this.items.length
              ? scrollBehaviorY.contentSize / this.items.length
              : 0;
          if (this.selectedIndex === undefined) {
              this.selectedIndex = this.options.selectedIndex || 0;
          }
          this.scroll.maxScrollX = 0;
          this.scroll.maxScrollY = -this.itemHeight * (this.items.length - 1);
          this.scroll.minScrollX = 0;
          this.scroll.minScrollY = 0;
          scrollBehaviorY.hasScroll =
              scrollBehaviorY.options && this.scroll.maxScrollY < this.scroll.minScrollY;
      };
      Wheel.prototype.getSelectedIndex = function () {
          return this.selectedIndex;
      };
      Wheel.prototype.wheelTo = function (index, time, ease, isSlient) {
          if (index === void 0) { index = 0; }
          if (time === void 0) { time = 0; }
          var y = -index * this.itemHeight;
          this.scroll.scrollTo(0, y, time, ease, isSlient);
      };
      Wheel.prototype.transitionDuration = function (time) {
          for (var i = 0; i < this.items.length; i++) {
              this.items[i].style[style.transitionDuration] =
                  time + 'ms';
          }
      };
      Wheel.prototype.timeFunction = function (easing) {
          for (var i = 0; i < this.items.length; i++) {
              this.items[i].style[style.transitionTimingFunction] = easing;
          }
      };
      Wheel.prototype.rotateX = function (y) {
          var _a = this.options.rotate, rotate = _a === void 0 ? 25 : _a;
          for (var i = 0; i < this.items.length; i++) {
              var deg = rotate * (y / this.itemHeight + i);
              this.items[i].style[style.transform] = "rotateX(" + deg + "deg)";
          }
      };
      Wheel.prototype.findNearestValidWheel = function (y) {
          y = y > 0 ? 0 : y < this.scroll.maxScrollY ? this.scroll.maxScrollY : y;
          var currentIndex = Math.abs(Math.round(-y / this.itemHeight));
          var cacheIndex = currentIndex;
          var items = this.items;
          var wheelDisabledItemClassName = this.options
              .wheelDisabledItemClass;
          // Impersonation web native select
          // first, check whether there is a enable item whose index is smaller than currentIndex
          // then, check whether there is a enable item whose index is bigger than currentIndex
          // otherwise, there are all disabled items, just keep currentIndex unchange
          while (currentIndex >= 0) {
              if (!hasClass(items[currentIndex], wheelDisabledItemClassName)) {
                  break;
              }
              currentIndex--;
          }
          if (currentIndex < 0) {
              currentIndex = cacheIndex;
              while (currentIndex <= items.length - 1) {
                  if (!hasClass(items[currentIndex], wheelDisabledItemClassName)) {
                      break;
                  }
                  currentIndex++;
              }
          }
          // keep it unchange when all the items are disabled
          if (currentIndex === items.length) {
              currentIndex = cacheIndex;
          }
          // when all the items are disabled, this.selectedIndex should always be -1
          return {
              index: this.wheelItemsAllDisabled ? -1 : currentIndex,
              y: -currentIndex * this.itemHeight
          };
      };
      Wheel.prototype.normalizeOptions = function () {
          var options = (this.options = isPlainObject(this.options)
              ? this.options
              : {});
          if (!options.wheelWrapperClass) {
              options.wheelWrapperClass = 'wheel-scroll';
          }
          if (!options.wheelItemClass) {
              options.wheelItemClass = 'wheel-item';
          }
          if (!options.rotate) {
              options.rotate = 25;
          }
          if (!options.adjustTime) {
              options.adjustTime = 400;
          }
          if (!options.wheelDisabledItemClass) {
              options.wheelDisabledItemClass = 'wheel-disabled-item';
          }
      };
      Wheel.prototype.checkWheelAllDisabled = function () {
          var wheelDisabledItemClassName = this.options
              .wheelDisabledItemClass;
          var items = this.items;
          this.wheelItemsAllDisabled = true;
          for (var i = 0; i < items.length; i++) {
              if (!hasClass(items[i], wheelDisabledItemClassName)) {
                  this.wheelItemsAllDisabled = false;
                  break;
              }
          }
      };
      Wheel.pluginName = 'wheel';
      return Wheel;
  }());

  return Wheel;

}));
